///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ (HALCON-10) Version 11.0
///////////////////////////////////////////////////////////////////////////////



#include "HalconCpp.h"



using namespace Halcon;

// Default exception handler 
void CPPExpDefaultExceptionHandler(const Halcon::HException& except)
{
  throw except;
}

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_Color, 
    Halcon::HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_String, Halcon::HTuple hv_CoordSystem, 
    Halcon::HTuple hv_Row, Halcon::HTuple hv_Column, Halcon::HTuple hv_Color, Halcon::HTuple hv_Box);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{
  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_Color, 
    Halcon::HTuple hv_Box)
{

  // Local control variables 
  HTuple  hv_ContinueMessage, hv_Row, hv_Column;
  HTuple  hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight;

  //This procedure displays 'Press Run (F5) to continue' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  hv_ContinueMessage = "Press Run (F5) to continue";
  get_window_extents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  get_string_extents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
      (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (Halcon::HTuple hv_WindowHandle, Halcon::HTuple hv_String, Halcon::HTuple hv_CoordSystem, 
    Halcon::HTuple hv_Row, Halcon::HTuple hv_Column, Halcon::HTuple hv_Color, Halcon::HTuple hv_Box)
{

  // Local control variables 
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_Width;
  HTuple  hv_Index, hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_Exception;
  HTuple  hv_CurrentColor;


  // Install default exception handler 
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If set to 'true', the text is written within a white box.
  //
  //prepare window
  get_rgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  get_part(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  get_window_extents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  set_part(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").Split("\n");
  //
  //Estimate extentions of text depending on font size.
  get_font_extents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, 
      &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //display text box depending on text size
  if (0 != (hv_Box==HTuple("true")))
  {
    //calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    HTuple end_val57 = (hv_String.Num())-1;
    HTuple step_val57 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val57, step_val57); hv_Index += step_val57)
    {
      get_string_extents(hv_WindowHandle, hv_String.Select(hv_Index), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.Concat(hv_W);
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.Num());
    hv_FrameWidth = (HTuple(0).Concat(hv_Width)).Max();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //display rectangles
    get_draw(hv_WindowHandle, &hv_DrawMode);
    set_draw(hv_WindowHandle, "fill");
    set_color(hv_WindowHandle, "light gray");
    disp_rectangle1(hv_WindowHandle, hv_R1+3, hv_C1+3, hv_R2+3, hv_C2+3);
    set_color(hv_WindowHandle, "white");
    disp_rectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    set_draw(hv_WindowHandle, hv_DrawMode);
  }
  else if (0 != (hv_Box!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Box";
    throw HException(hv_Exception);
  }
  //Write text.
  HTuple end_val78 = (hv_String.Num())-1;
  HTuple step_val78 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val78, step_val78); hv_Index += step_val78)
  {
    hv_CurrentColor = hv_Color.Select(hv_Index%(hv_Color.Num()));
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).And(hv_CurrentColor!=HTuple("auto"))))
    {
      set_color(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      set_rgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    set_tposition(hv_WindowHandle, hv_Row, hv_C1);
    write_string(hv_WindowHandle, hv_String.Select(hv_Index));
  }
  //reset changed window settings
  set_rgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  set_part(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables 
  Hobject  ho_Image, ho_Rectangle, ho_ImageReduced;
  Hobject  ho_Matches, ho_MergedMatches, ho_ConnMatches, ho_ImageMatches;


  // Local control variables 
  HTuple  hv_Online, hv_AcqHandle, hv_Width, hv_Height;
  HTuple  hv_WindowHandle, hv_Index, hv_Row1, hv_Column1;
  HTuple  hv_Row2, hv_Column2, hv_TemplateID, hv_TemplateHeight2;
  HTuple  hv_TemplateWidth2, hv_Area, hv_Row, hv_Column, hv_Error;
  HTuple  hv_NumMatches, hv_BestMatchIndex, hv_BestMatchError;
  HTuple  hv_I;

  //
  //Online pattern matching
  //***************************************************************
  //This example shows how to perform online pattern matching using
  //an adaptive gray-value template on images acquired by an image
  //acquisition device.
  //If the variable 'Online' is set to 'true' the images are acquired
  //by the image acquisition device specified in open_framegrabber().
  //Otherwise a virtual image acquisition device is used to read an
  //image sequence.
  //
  //For other examples on template matching check the programs pm_*.hdev
  //
  //
  dev_update_off();
  if (HDevWindowStack::IsOpen())
    close_window(HDevWindowStack::Pop());
  //
  //Open an image acquisition device
  //-----------------------------------------------------------------
  //If Online is set to 'true' the specified image acquisition device
  //is opened. Otherwise a virtual image acquisition device is opened.
  hv_Online = 0;
  if (0 != hv_Online)
  {
    open_framegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "progressive", -1, "default", 
        -1, "false", "default", "default", 0, 0, &hv_AcqHandle);
  }
  else
  {
    open_framegrabber("File", 1, 1, 0, 0, 0, 0, "default", -1, "default", -1, "false", 
        "card/card", "", 1, 2, &hv_AcqHandle);
  }
  //
  //Grab and display an image
  grab_image(&ho_Image, hv_AcqHandle);
  get_image_size(ho_Image, &hv_Width, &hv_Height);
  set_window_attr("background_color","black");
  open_window(0,0,hv_Width,hv_Height,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    disp_obj(ho_Image, HDevWindowStack::GetActive());
  //
  //Display settings
  if (HDevWindowStack::IsOpen())
    set_color(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    set_draw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    set_line_width(HDevWindowStack::GetActive(),3);
  //
  //Set up
  if (0 != hv_Online)
  {
    for (hv_Index=0; hv_Index<=100; hv_Index+=1)
    {
      grab_image(&ho_Image, hv_AcqHandle);
      if (HDevWindowStack::IsOpen())
        disp_obj(ho_Image, HDevWindowStack::GetActive());
    }
  }
  //
  //Define a template for the pattern matching
  //--------------------------------------------------------
  //Define a pattern for the matching which is then further
  //preprocessed for the template matching.
  //For Online = true, a pattern is generated by drawing a rectangle.
  //For Online = false, a default pattern is loaded.
  if (0 != hv_Online)
  {
    //
    //Generate a pattern
    draw_rectangle1(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    gen_rectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    if (HDevWindowStack::IsOpen())
      disp_obj(ho_Rectangle, HDevWindowStack::GetActive());
    reduce_domain(ho_Image, ho_Rectangle, &ho_ImageReduced);
    create_template(ho_ImageReduced, 5, 4, "sort", "original", &hv_TemplateID);
  }
  else
  {
    //
    //Load a default pattern
    hv_Row1 = 164.5;
    hv_Row2 = 196.5;
    hv_Column1 = 152.5;
    hv_Column2 = 229.5;
    gen_rectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    if (HDevWindowStack::IsOpen())
      disp_obj(ho_Rectangle, HDevWindowStack::GetActive());
    reduce_domain(ho_Image, ho_Rectangle, &ho_ImageReduced);
    create_template(ho_ImageReduced, 5, 4, "sort", "original", &hv_TemplateID);
  }
  disp_message(hv_WindowHandle, "Initial template for pattern matching", "window", 
      10, 10, "black", "true");
  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(); only in hdevelop
  //
  //Determine the half of template width and height
  hv_TemplateHeight2 = (hv_Row2-hv_Row1)/2.0;
  hv_TemplateWidth2 = (hv_Column2-hv_Column1)/2.0;
  //
  //Pattern matching
  //--------------------------------------------------------
  //Search for best matches of the template in the image and
  //display the found template. If matches with small errors
  //were found, adapt the pattern for the next matching.
  for (hv_Index=0; hv_Index<=80; hv_Index+=1)
  {
    //
    //Grab and display an image for the matching
    if (0 != hv_Online)
    {
      grab_image_async(&ho_Image, hv_AcqHandle, -1);
    }
    else
    {
      grab_image(&ho_Image, hv_AcqHandle);
    }
    if (HDevWindowStack::IsOpen())
      disp_obj(ho_Image, HDevWindowStack::GetActive());
    //
    //Adapt the template to the size of the image
    adapt_template(ho_Image, hv_TemplateID);
    //
    //Search all matches of the template in the image and
    //return all points showing an error smaller than 20
    fast_match_mg(ho_Image, &ho_Matches, hv_TemplateID, 20, 3);
    area_center(ho_Matches, &hv_Area, &hv_Row, &hv_Column);
    if (0 != (hv_Area>0))
    {
      dilation_circle(ho_Matches, &ho_MergedMatches, 3.5);
      connection(ho_MergedMatches, &ho_ConnMatches);
      add_channels(ho_ConnMatches, ho_Image, &ho_ImageMatches);
      //
      //Search the best match of the template and display
      //the found template
      best_match(ho_ImageMatches, hv_TemplateID, 20, "true", &hv_Row, &hv_Column, 
          &hv_Error);
      hv_NumMatches = hv_Row.Num();
      hv_BestMatchIndex = -1;
      hv_BestMatchError = 255;
      HTuple end_val114 = hv_NumMatches-1;
      HTuple step_val114 = 1;
      for (hv_I=0; hv_I.Continue(end_val114, step_val114); hv_I += step_val114)
      {
        if (0 != ((hv_Error.Select(hv_I))<255))
        {
          disp_message(hv_WindowHandle, "Template found", "window", 10, 10, "black", 
              "true");
          disp_rectangle1(hv_WindowHandle, (hv_Row.Select(hv_I))-hv_TemplateHeight2, 
              (hv_Column.Select(hv_I))-hv_TemplateWidth2, (hv_Row.Select(hv_I))+hv_TemplateHeight2, 
              (hv_Column.Select(hv_I))+hv_TemplateWidth2);
          hv_BestMatchIndex = hv_I;
          hv_BestMatchError = hv_Error.Select(hv_I);
        }
      }
      //
      //Adapt the pattern
      //--------------------------------------------------------
      //Create a new template for the matching if the gray value
      //difference of the last best match is smaller than 15
      if (0 != (hv_BestMatchIndex>=0))
      {
        if (0 != (hv_BestMatchError<15))
        {
          clear_template(hv_TemplateID);
          gen_rectangle1(&ho_Rectangle, (hv_Row.Select(hv_BestMatchIndex))-hv_TemplateHeight2, 
              (hv_Column.Select(hv_BestMatchIndex))-hv_TemplateWidth2, (hv_Row.Select(hv_BestMatchIndex))+hv_TemplateHeight2, 
              (hv_Column.Select(hv_BestMatchIndex))+hv_TemplateWidth2);
          reduce_domain(ho_Image, ho_Rectangle, &ho_ImageReduced);
          create_template(ho_ImageReduced, 5, 4, "sort", "original", &hv_TemplateID);
        }
      }
    }
  }
  clear_template(hv_TemplateID);
  close_framegrabber(hv_AcqHandle);
}


#ifndef NO_EXPORT_APP_MAIN
int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  set_system("width", 512);
  set_system("height", 512);
  action();
  return 0;
}
#endif


#endif


